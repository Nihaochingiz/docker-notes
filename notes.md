**Что такое контейнер**

Контейнер - это процесс в песочнице, запущенный на хост-машине, который изолирован от всех других процессов, запущенных на этой хост-машине. Для такой изоляции используются пространства имен ядра и cgroups - функции, которые уже давно существуют в Linux. Docker делает эти возможности доступными и простыми в использовании

Итог:
Контейнер - это использующийся экземпляр image

Вы можете создавать, запускать, останавливать, переносить или удалять контейнеры через docker

Контейнеры могут запускаться в облаке, на вашей машине и на хост машине

Также есть изолированность от других контейнеров, собственное по, двоичные файлы и конфигурации

Example Docker File
```
# syntax=docker/dockerfile:1

FROM node:18-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "src/index.js"]
EXPOSE 3000
```
**Команда для сборки image**
```
docker build -t getting-started .
```
Точка в конце говорит о том, что нужно искать Dockerfile
в текущем каталоге

**Команда для запуска контейнера**
```
docker run -dp 127.0.0.1:3000:3000 getting-started
```
**Увидеть работающие контейнеры**
```
docker ps
```


**Docker network**

Сетевое взаимодействие контейнеров - это возможность контейнеров
подключаться и взаимодействовать друг с другом

По умолчанию у контейнеров включена сетевая связь, и они могут устанавливать исходящие соединения.

Контейнер не иммеет информации к какой сети он привязан

Контейнер видит только сетевой интерфейс с IP-адресом, шлюз, таблицу маршрутизации, службы DNS и другие сетевые данные. Это если контейнер не использует сетевой драйвер none.

**User-defined networks**

Вы можете создавать custom networks
И соединять несколько контейнеров к одной сети

После подключения к custom network пользователя контейнеры могут взаимодействовать друг с другом, используя IP-адреса контейнеров или их имена.

**Пример создания сети, используя bridge network driver**
**Также пример запуска контейнера в созданной сети**
```
docker network create -d bridge my-net
docker run --network=my-net -itd --name=container3 busybox
```

**Container networks**
В дополнение вы можете привязать один контейнер к сети другого контейнера

Команда
```
--network container:<name|id>
```

В следующем примере запускается контейнер Redis с привязкой Redis к localhost, затем выполняется команда redis-cli и устанавливается соединение с сервером Redis через интерфейс localhost.
```
docker run -d --name redis example/redis --bind 127.0.0.1
docker run --rm -it --network container:redis example/redis-cli -h 127.0.0.1
```

**Published Ports**
По умолчанию, когда вы создаете или запускаете контейнер с помощью docker create или docker run, контейнер не раскрывает свои порты внешнему миру. Чтобы сделать порт доступным для служб за пределами Docker, используйте флаг --publish или -p. При этом на хосте создается правило брандмауэра, сопоставляющее порт контейнера с портом на хосте Docker для внешнего мира. Вот несколько примеров:

| Flag value    |Description |
| -------- | ------- |
| -p 8080:80  | Map port 8080 on the Docker host to TCP port 80 in the container.    |
| -p 192.168.1.100:8080:80 | Map port 8080 on the Docker host IP 192.168.1.100 to TCP port 80 in the container.  | 	Map port 8080 on the Docker host IP 192.168.1.100 to TCP port 80 in the container.
| -p 8080:80/tcp -p 8080:80/udp   | Map TCP port 8080 on the Docker host to TCP port 80 in the container, and map UDP port 8080 on the Docker host to UDP port 80 in the container.    |


**IP address and hostname**

